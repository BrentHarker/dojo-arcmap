require({cache:{
'url:esri/views/3d/environment/materials/RealisticAtmosphereMaterial.xml':"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<snippets>\n\n<!--Vertex Shader for Atmosphere-->\n<snippet name=\"vsRealisticAtmosphere\"><![CDATA[\n//\n// Based on Atmospheric scattering vertex shader by Sean O'Neil from GPU Gems 2 Chapter 16.\n//\n// Link:                   http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n// Download Portal:        http://http.download.nvidia.com/developer/GPU_Gems_2/CD/Index.html\n// Unmodified Source Code: http://http.download.nvidia.com/developer/GPU_Gems_2/CD/Content/16.zip\n//\n// Adapted for WebGIS by Jascha Grübel (jgruebel@esri.com), Zürich 2015\n//\n\n  $vsprecisionf\n\n  //Camera\n  uniform vec2 halfSizeNearPlane;\n  uniform vec3 v3CameraUp;\n  uniform vec3 v3CameraRight;\n  uniform vec3 v3CameraDir;\n  uniform vec2 v2CameraCenterOffset;\n\n  //Attributes\n  attribute vec3 $position;\n  attribute vec2 $uv0;\n\n  //Varyings\n  varying vec3 v3WorldRay;\n  varying vec2 vtc;\n\n#ifdef HAZE\n  varying vec3 v3EyeDir;\n#endif\n\n  void main(void) {\n    vec3 v3Pos = $position;\n    vtc = $uv0;\n    vec2 rayvtc = $uv0 - v2CameraCenterOffset;\n\n#ifdef HAZE\n    v3EyeDir = vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\n#else\n    vec3 v3EyeDir = vec3((2.0*halfSizeNearPlane *rayvtc)-halfSizeNearPlane,-1.0);\n#endif\n    v3WorldRay = v3EyeDir.z*v3CameraDir + v3EyeDir.y*v3CameraUp + v3EyeDir.x*v3CameraRight;\n    gl_Position = vec4(v3Pos, 1.0);\n  }\n]]></snippet>\n\n<snippet name=\"atmosphereScaleFunction\"><![CDATA[\n  //Approximation for inner integral based on a radii ratio of 10.25:10\n  float scale(float fCos){\n    float x = 1.0 - fCos;\n    return exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n  }\n]]></snippet>\n\n<snippet name=\"toneMapperConstants\"><![CDATA[\n#ifdef HAZE\n  const float fOneOverGamma = 1.0;//Gamma = 1.0\n#else\n  const float fOneOverGamma = 0.454545; // Gamma = 2.2\n#endif\n  const vec3 v3OneOverGamma = vec3(fOneOverGamma);\n\n]]></snippet>\n\n<snippet name=\"exponentialToneMapper\"><![CDATA[\n  //ToneMapping operators\n  vec3 expTM(vec3 inputColor,float exposure){\n      return pow(1.0 - exp(inputColor * -exposure), v3OneOverGamma);\n  }\n]]></snippet>\n\n<snippet name=\"reinhardToneMapper\"><![CDATA[\n  vec3 reinhardTM(vec3 inputColor, float exposure){\n      vec3 intermediate = inputColor *exposure;\n      intermediate /= (1.0+intermediate);\n      return pow(intermediate, v3OneOverGamma);\n  }\n]]></snippet>\n\n\n<snippet name=\"HSVColorSpace\"><![CDATA[\n//based on http://gamedev.stackexchange.com/a/59808\n// Hue in range [0,1] instead of 360°\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n]]></snippet>\n\n<snippet name=\"atmosphereUniformsConstantsVaryings\"><![CDATA[\n\n  //Light\n  uniform vec3 v3LightDir;      // The direction vector to the light source\n  uniform vec3 v3InvWavelength; // 1 / pow(wavelength, 4) for the red, green, and blue channels\n  uniform vec3 v3InvWavelengthScaled; //v3InvWavelength * fKr4PI + fKm4PI\n\n  //Radii\n  uniform vec4 v4Radii; // inner, inner^2, outer, outer^2,\n\n  //Atmosphere\n  const float fKrESun = 0.075;        // Kr * ESun = 0.005 * 15.0\n  const float fKmESun = 0.015;        // Km * ESun = 0.005 * 15\n  //uniform float fScale;         // 1 / (fOuterRadius - fInnerRadius)\n  //uniform float fScaleDepth;    // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n  //uniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n  //uniform float fOneOverScaleDepth; // 1.0 / fScaleDepth\n\n  //uniform float fScaleDepthBlue;    // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n  //uniform float fScaleOverScaleDepthBlue; // fScale / fScaleDepth\n  //uniform float fOneOverScaleDepthBlue; // 1.0 / fScaleDepth\n\n  uniform vec4 v4AtmosParams1; //(fScale,fScaleDepth,fScaleOverScaleDepth,fOneOverScaleDepth)\n  uniform vec4 v4AtmosParams2; //(g,fScaleDepthBlue,fScaleOverScaleDepthBlue,fOneOverScaleDepthBlue)\n#ifndef HAZE\n  uniform vec4 v4AtmosParams3; //(g2,fMiePhaseCoefficients,fLowerAlphaBlendBound,fOneOverOuterRadiusMinusAlphaBlendBound)\n#endif\n\n  //Camera\n  uniform vec3 v3CameraPos;     // The camera's current position\n  //uniform float fCameraHeight;  // The camera's current height\n  //uniform float fCameraHeight2; // fCameraHeight^2\n  //uniform float fC; //fCameraHeight2 - fOuterRadius2; // C = ||o-c||^2 - r^2\n  //uniform float fCSur; //fCameraHeight2 - (fInnerRadius2 - 63756370000.0); // C = ||o-c||^2 - r^2\n  uniform vec4 v4SphereComp; //The camera's current height, CameraHeight^2,fC,fCSur\n  uniform vec2 nearFar;\n\n  //Camera HDR\n#ifdef HAZE\n  const float fExposure = 1.5;\n#else\n  const float fExposure = 2.0;\n#endif\n\n#ifdef HAZE\n  //Depth texture\n  uniform sampler2D tDepth;\n#endif\n\n  //Testing variables\n  uniform float showTest;\n\n  //Varyings\n  varying vec3 v3EyeDir;\n  varying vec3 v3WorldRay;\n  varying vec2 vtc;\n\n  //Loop constants for integral approximation\n  const float fSamples = 5.0;\n  const int maxSamples = 5;\n]]></snippet>\n\n\n<snippet name=\"atmospherePrecomputation\"><![CDATA[\n    float fInnerRadius = v4Radii[0];   // The inner (planetary) radius\n    float fInnerRadius2 = v4Radii[1];  // fInnerRadius^2\n    float fOuterRadius = v4Radii[2];   // The outer (atmosphere) radius\n    float fOuterRadius2 = v4Radii[3];  // fOuterRadius^2\n\n    float fCameraHeight = v4SphereComp[0];\n    float fCameraHeight2 = v4SphereComp[1];\n    float fC = v4SphereComp[2];\n    float fCSur = v4SphereComp[3];\n\n#ifdef PLANAR\n    vec3 cameraPosition = vec3(0.0,0.0,fCameraHeight);\n#else\n    vec3 cameraPosition = v3CameraPos;\n#endif\n\n    //Debug variables\n    vec3 test = vec3(0.0,0.0,0.0);\n\n    //Obtain ray from Camera\n    vec3 worldSpaceRay = normalize(v3WorldRay);\n\n    //Compute Atmosphere intersection; i.e. ray/sphere intersection\n    float B = 2.0 * dot(cameraPosition, worldSpaceRay); // B = 2(l * (o-c))\n    float det = B*B - 4.0 * fC; // det = B^2 - 4.0* C\n\n    //idealized sphere intersection to discard early some pixels\n    float detSur = B*B - 4.0 * fCSur; // det = B^2 - 4.0* C\n\n]]></snippet>\n\n\n<snippet name=\"atmosphereDiscardPixels\"><![CDATA[\n      bool continueComputation = true;\n#ifdef HAZE\n      // only use red channel from depth texture.\n      // see 'Issues' at https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture\n      float depthSample = texture2D(tDepth, vtc).r;\n\n      float zNear = nearFar[0];\n      float zFar = nearFar[1];\n\n      // http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\n      float zNorm = 2.0 * depthSample - 1.0;\n      float linDepth = 2.0 * zNear * zFar /\n        (zFar + zNear - zNorm * (zFar - zNear));\n\n      float nearSurfaceT;\n      if (detSur>0.0){\n        nearSurfaceT = 0.5 *(-B - sqrt(detSur));\n      }\n\n      float rayEndT;\n\n      // find intersections with ground, but only between the near and far\n      // clipping planes.\n      if (depthSample < 1.0 && depthSample > 0.0) {\n        vec3 cameraSpaceRay = normalize(v3EyeDir);\n        cameraSpaceRay /= cameraSpaceRay.z;\n        cameraSpaceRay *= linDepth;\n#ifndef PLANAR\n        if((fCameraHeight-fInnerRadius)>8000000.0 && detSur>0.0){\n          rayEndT = nearSurfaceT;\n        } else  if ((fCameraHeight-fInnerRadius)>2000000.0 && detSur>0.0){\n          rayEndT = mix(length(cameraSpaceRay),nearSurfaceT,((fCameraHeight-fInnerRadius)-2000000.0)/6000000.0);\n        } else {\n          rayEndT = length(cameraSpaceRay);\n        }\n#else\n        rayEndT = length(cameraSpaceRay);\n#endif\n      } else {\n        continueComputation = false;\n      }\n#ifdef PLANAR\n      if (16500.0+ fInnerRadius < fCameraHeight){\n        continueComputation = false;\n      }\n#endif\n#else\n      if (detSur>0.0){\n        float nearSurfaceT = 0.5 *(-B - sqrt(detSur));\n        if (nearSurfaceT > 0.0){\n          continueComputation = false;\n        }\n      }\n#endif\n\n]]></snippet>\n\n<snippet name=\"atmosphereUnpackAddUniforms\"><![CDATA[\n        float fScale = v4AtmosParams1.x;\n        vec2 v2ScaleDepth = vec2(v4AtmosParams1.y,v4AtmosParams2.y);//fScaleDepth, fScaleDepthBlue\n        vec2 v2ScaleOverScaleDepth = vec2(v4AtmosParams1.z,v4AtmosParams2.z);//fScaleOverScaleDepth, fScaleOverScaleDepthBlue\n        vec2 v2OneOverScaleDepth = vec2(v4AtmosParams1.w,v4AtmosParams2.w);//fOneOverScaleDepth, fOneOverScaleDepthBlue\n\n#ifndef HAZE\n        float g = v4AtmosParams2.x;\n        float g2 = v4AtmosParams3.x;\n        float fMiePhaseCoefficients = v4AtmosParams3.y;\n        float fLowerAlphaBlendBound = v4AtmosParams3.z;\n        float fOneOverOuterRadiusMinusAlphaBlendBound = v4AtmosParams3.w;\n#endif\n]]></snippet>\n\n\n<snippet name=\"atmosphereComputeRayAndLoopSetup\"><![CDATA[\n        float rayStartT = 0.5 *(-B - sqrt(det)); //near intersection with atmosphere\n#ifdef HAZE\n        float nearT = abs(rayStartT);\n        float farT = abs(rayEndT);\n#else\n        float rayEndT = 0.5 *(-B + sqrt(det)); //far intersection with atmosphere\n\n#endif\n\n        float fDistance;//calculate its scattering offset\n        // Calculate the ray's starting position\n        if (rayStartT < 0.0)\n        { //ray starts from camera to far\n          rayStartT = 0.0;\n#ifndef HAZE\n          fDistance = fScale*(fInnerRadius - fCameraHeight);\n#endif\n        }\n#ifndef HAZE\n        else\n        {//outside atmosphere\n          fDistance = -1.0;\n        }\n#endif\n\n        // Initialize the scattering loop variables\n        vec3 v3Start = cameraPosition + worldSpaceRay * rayStartT;\n\n#ifdef HAZE\n        vec3 v3End = cameraPosition + worldSpaceRay * rayEndT;\n\n        float fEndLength = length(v3End);\n        float fLocalCameraHeight = length(v3Start);\n\n        //computed for the original end point to get consistent light angles after possible inversions\n        float fLightAngle = dot(v3LightDir, v3End) / fEndLength;\n\n        if (nearT > farT)\n        {\n          if (fLocalCameraHeight < fEndLength)\n          {\n            //Switch positive slopes for flipped rays\n            v3End = cameraPosition + worldSpaceRay * rayStartT;\n            v3Start = cameraPosition + worldSpaceRay * rayEndT;\n            worldSpaceRay *= -1.0;\n            fEndLength = length(v3End);\n            fLocalCameraHeight = length(v3Start);\n          }\n          else if (fLocalCameraHeight == fEndLength)\n          {// create minuscule fake slope for integration if the slope is zero\n            fLocalCameraHeight += 1.0; //BUGFIX, if the height of camera and ground is equal the equation breaks, add fake meter to camera height to get\n            //slope for the camera function\n          }\n        }\n\n        //Calculate its scattering offset\n        // Assumes camera constrains of WSV 3.8\n        float fCameraDepth;\n        float fCameraDepthBlue;\n        if (fLocalCameraHeight > fOuterRadius)\n        {\n          fDistance = fInnerRadius - fOuterRadius;\n        } else\n        {//outside atmosphere\n          fDistance = fEndLength - fLocalCameraHeight;\n        }\n\n#endif\n        vec2 v2OpticalStartDepth = exp(fDistance * v2OneOverScaleDepth);\n\n        float fRayLength = rayEndT - rayStartT;\n        float fSampleLength = fRayLength / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = worldSpaceRay * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n#ifdef HAZE\n        float fCameraAngle = dot(-worldSpaceRay, v3End) / fEndLength;\n        float fScaleCameraAngle = scale(fCameraAngle);\n        vec2 v2CameraOffset = fScaleCameraAngle*v2OpticalStartDepth;\n\n        float scaledValues = scale(fLightAngle) + fScaleCameraAngle;\n        vec2 v2ScaledValuesDepth = scaledValues * v2ScaleDepth;\n#else\n        float fCameraAngle = dot(worldSpaceRay, v3Start / length(v3Start));\n        float angleMultiplier = fCameraAngle>0.0?fCameraAngle:0.0;\n\n        float fScaleCameraAngle = scale(fCameraAngle);\n        vec2 v2CameraOffset = fScaleCameraAngle*v2OpticalStartDepth * v2ScaleDepth;\n#endif\n\n        //Loop variables\n        vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n        vec3 v3FrontColorBlue = vec3(0.0, 0.0, 0.0);\n        vec3 v3Attenuate= vec3(0.0, 0.0, 0.0);\n        vec3 v3AttenuateBlue = vec3(0.0, 0.0, 0.0);\n]]></snippet>\n\n\n<snippet name=\"atmosphereComputeSampleContribution\"><![CDATA[\n          float fHeight = length(v3SamplePoint);\n          vec2 v2Depth = exp(v2ScaleOverScaleDepth * (fInnerRadius - fHeight));\n#ifdef HAZE\n          vec2 v2Scatter = v2Depth*v2ScaledValuesDepth-v2CameraOffset;\n#else\n          float fLightAngle = dot(v3LightDir, v3SamplePoint) / fHeight;\n          float fCameraAngle = dot(worldSpaceRay, v3SamplePoint) / fHeight;\n          float fTempScaledValues = scale(fLightAngle) - scale(fCameraAngle);\n          vec2 v2Scatter = v2CameraOffset + fTempScaledValues*v2Depth* v2ScaleDepth;\n#endif\n          v3Attenuate = exp(-v2Scatter.x * v3InvWavelengthScaled);\n          v3AttenuateBlue = exp(-v2Scatter.y * v3InvWavelengthScaled);\n\n          v3FrontColor += v3Attenuate * v2Depth.x;\n          v3FrontColorBlue += v3AttenuateBlue * v2Depth.y;\n\n          v3SamplePoint += v3SampleRay;\n]]></snippet>\n\n\n<snippet name=\"atmosphereComputeHDRColors\"><![CDATA[\n        //Phase computation\n        //clamp to avoid numerical instability at fCos == -1.0 (and close values) to display fake sun\n        float fCos = clamp(dot(v3LightDir, -worldSpaceRay ),-0.9999999,1.0);\n        float fOnePlusCos2 = fCos*fCos + 1.0;\n#ifdef HAZE\n        // Finally, scale the Rayleigh colors and set up the varying variables for the pixel shader\n        vec3 colorCoefficients = (fScaledLength* 0.75 * fOnePlusCos2)*(fKrESun*v3InvWavelength+fKmESun);\n\n        //Scaled Length is only applied afterwards to save multiplications\n        vec3 v3Color = colorCoefficients *v3FrontColor;\n        vec3 v3ColorBlue = colorCoefficients *v3FrontColorBlue;\n#else\n        vec3 v3RayleighCoefficients = (fScaledLength*0.75 * fOnePlusCos2*fKrESun)*v3InvWavelength;\n        float fMieCoefficients = fScaledLength*fKmESun * fMiePhaseCoefficients * fOnePlusCos2 / pow(1.0 + g2 - 2.0*g*fCos, 1.5);\n\n        // Calculate the attenuation factor for the ground\n        vec3 v3Color = v3RayleighCoefficients * v3FrontColor + fMieCoefficients * v3FrontColor;\n        vec3 v3ColorBlue = v3RayleighCoefficients * v3FrontColorBlue + fMieCoefficients * v3FrontColorBlue;\n#endif\n]]></snippet>\n\n\n<snippet name=\"atmosphereComputePixelColor\"><![CDATA[\n\n\n        //HDR to LDR conversion\n        vec3 ldrBlue = expTM(v3ColorBlue,2.0*fExposure);\n        vec3 ldrRed = expTM(v3Color,fExposure);\n\n        //mix reddish and blueish atmosphere\n        vec3 LDR = mix(ldrBlue,ldrRed,0.2);\n#ifdef HAZE\n        LDR *= (1.0-fCameraAngle);\n        vec3 hsv = rgb2hsv(LDR);\n        hsv.y = clamp(hsv.y*1.5,0.0,1.0);//boost haze saturation by 50%\n        LDR = hsv2rgb(hsv);\n        vec3 finalColor = LDR;\n        // when rendering we specify the blend functions such that\n        // newDestColor = oldDestColor*(1.0-finalColor) + finalColor\n#else\n        //reinhard tonemapper for looking upwards\n        vec3 ldrReinhard = reinhardTM(v3Color,fExposure);\n        LDR += angleMultiplier*ldrReinhard;\n\n        //height dependent parameter to smooth out reddish atmosphere\n        float side = (rayEndT+rayStartT)*0.5;\n        float atmoHeight = sqrt(fCameraHeight2 - side*side);\n        float h2 = clamp(1.0-(atmoHeight-fLowerAlphaBlendBound)/(fOuterRadius-fLowerAlphaBlendBound),0.0,1.0);\n\n        vec3 finalColor = LDR*h2;\n        vec3 hsv = rgb2hsv(finalColor);\n        hsv.y = clamp(hsv.y*1.5,0.0,1.0);//boost sky saturation by 50%\n        finalColor = hsv2rgb(hsv);\n#endif\n#ifdef PLANAR\n#ifndef HAZE\n        float alpha = clamp(fCameraHeight-fInnerRadius,7000.0,30000.0);\n        alpha = alpha / (30000.0-7000.0);\n        gl_FragColor = vec4(finalColor, 1.0-alpha);\n#else\n        float alpha = clamp(fCameraHeight-fInnerRadius,0.0,16500.0);\n        alpha = alpha / (16500.0-0.0);\n        gl_FragColor = vec4(finalColor, 1.0-alpha);\n#endif\n#else\n#ifndef HAZE\n        float alpha = clamp(fCameraHeight-fInnerRadius,7000.0,30000.0);\n        alpha = alpha / (30000.0-7000.0);\n        float atmosStrength = clamp((length(ldrRed)-0.05)*1.05,0.0,1.0);\n        gl_FragColor = vec4(finalColor, atmosStrength*clamp(1.0-(atmoHeight-fInnerRadius)/(fOuterRadius-fInnerRadius),0.0,1.0));\n#else\n        gl_FragColor = vec4(finalColor, 1.0);\n#endif\n#endif\n\n\n]]></snippet>\n\n<!--Fragment Shader for Atmosphere-->\n<snippet name=\"fsRealisticAtmosphere\"><![CDATA[\n\n  $fsprecisionf\n\n$atmosphereUniformsConstantsVaryings\n\n$atmosphereScaleFunction\n\n  //Conversion implementation found in util.xml\n$rgba2float\n\n\n$toneMapperConstants\n$exponentialToneMapper\n#ifndef HAZE\n$reinhardToneMapper\n#endif\n\n$HSVColorSpace\n\n  void main()\n  {\n\n    $atmospherePrecomputation\n\n    //Inside Atmosphere\n    if (det >= 0.0){\n\n      $atmosphereDiscardPixels\n\n      if(continueComputation){\n\n        $atmosphereUnpackAddUniforms\n\n        $atmosphereComputeRayAndLoopSetup\n\n        // Now loop through the sample rays\n        for(int i=0; i<maxSamples; i++)\n        {\n          $atmosphereComputeSampleContribution\n        }\n\n        $atmosphereComputeHDRColors\n\n        $atmosphereComputePixelColor\n\n        //Debug variable overlay\n        if(showTest>0.0){\n          gl_FragColor = vec4(test,1.0);\n        }\n\n      } else {//Not on surface\n        gl_FragColor = vec4(0.0);\n      }\n    } else {//Outside Atmosphere\n      gl_FragColor = vec4(0.0);\n    }\n  }\n]]></snippet>\n\n</snippets>\n"}});
// COPYRIGHT © 2017 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.4/esri/copyright.txt for details.

define(["dojo/text!./materials/RealisticAtmosphereMaterial.xml","../../../core/watchUtils","../../../core/HandleRegistry","../support/ExternalRenderer","../lib/glMatrix","../webgl-engine/lib/GeometryRenderer","../webgl-engine/lib/GeometryUtil","../webgl-engine/lib/RenderPass","../webgl-engine/lib/RenderSlot","../webgl-engine/lib/OffscreenRenderingHelper","../support/earthUtils","../../webgl/Program","../webgl-engine/lib/DefaultVertexBufferLayouts","../webgl-engine/lib/DefaultVertexAttributeLocations"],function(e,a,t,r,s,i,n,h,o,l,d,v,m,_){var f=d.earthRadius,u=s.vec3d,p=s.vec2d,c=s.vec4d,g=.005,D=.001,P=4*g*Math.PI,S=4*D*Math.PI,C=u.createFrom(1/Math.pow(.65,4),1/Math.pow(.57,4),1/Math.pow(.475,4)),R=u.create(C);u.scale(R,P),u.add(R,u.createFrom(S,S,S));var A=.25,w=.05,b=1/A,U=1/w,E=-.99999,O=1.5*((1-E*E)/(2+E*E)),T=r.createSubclass({declaredClass:"esri.views.3d.environment.RealisticAtmosphere",properties:{view:{},planar:{value:!1,set:function(e){e=!!e,e!==this.planar&&this._update(),this._set("planar",e)}},needsRender:{value:!1}},constructor:function(){this._handles=new t,this._lowerElevationBoundRadius=0,this._earthRadius=f,this._hazeProgram=null,this._hazePlanarProgram=null,this._skyProgram=null,this._skyPlanarProgram=null,this._renderer=null,this._renderData={texDepth:p.create(),v3CameraPos:u.create(),v3CameraUp:u.create(),v3CameraRight:u.create(),v3CameraDir:u.create(),v3CameraCenter:u.create(),halfSizeNearPlane:p.create(),v2CameraCenterOffset:p.create(),v4SphereComp:c.create(),v4AtmosParams1:c.create(),v4AtmosParams2:c.create(),v4AtmosParams3:c.create(),v3InvWavelength:C,v3InvWavelengthScaled:R,v4Radii:c.create(),fScale:0,fScaleDepth:A,fLowerAlphaBlendBound:0,fScaleOverScaleDepth:0,fOneOverScaleDepth:0,fScaleDepthBlue:w,fOneOverScaleDepthBlue:U,fScaleOverScaleDepthBlue:0,g:E,g2:E*E,fMiePhaseCoefficients:O,showTest:0,nearFar:p.create()},this._updateRadius(f),this._hazeSlot=o.POSTPROCESSING_ATMOSPHERE,this._skySlot=o.BACKGROUND},destroy:function(){this._handles&&(this._handles.destroy(),this._handles=null),this._hazeProgram&&(this._hazeProgram.dispose(),this._hazeProgram=null),this._hazePlanarProgram&&(this._hazePlanarProgram.dispose(),this._hazePlanarProgram=null),this._skyProgram&&(this._skyProgram.dispose(),this._skyProgram=null),this._skyPlanarProgram&&(this._skyPlanarProgram.dispose(),this._skyPlanarProgram=null)},setup:function(t){var r=n.createSquareGeometry(),s={faces:r.getFaces()[0],vertexAttr:r.getVertexAttr()},h=this.renderContext.rctx;this._renderer=new i(s,m.Pos3Tex,null,h);var o=this._update.bind(this);this._handles.add(a.on(this,"view.navigation","currentViewChanged",function(e){o(e.camera)},function(){o()},null,!0));var l=this._updateElevation.bind(this),d=this._updateVisibleElevationBounds.bind(this);this._handles.add(a.on(this,"view.basemapTerrain","elevation-change",l,l)),this._handles.add(a.on(this,"view.basemapTerrain","elevation-bounds-change",d,d)),t.shaderSnippets.fsRealisticAtmosphere||t.shaderSnippets._parse(e),this._hazeProgram=new v(h,t.shaderSnippets.vsRealisticAtmosphere,t.shaderSnippets.fsRealisticAtmosphere,_.Default3D,["HAZE"]),this._skyProgram=new v(h,t.shaderSnippets.vsRealisticAtmosphere,t.shaderSnippets.fsRealisticAtmosphere,_.Default3D),this._hazePlanarProgram=new v(h,t.shaderSnippets.vsRealisticAtmosphere,t.shaderSnippets.fsRealisticAtmosphere,_.Default3D,["HAZE","PLANAR"]),this._skyPlanarProgram=new v(h,t.shaderSnippets.vsRealisticAtmosphere,t.shaderSnippets.fsRealisticAtmosphere,_.Default3D,["PLANAR"])},render:function(e){if(!(e.slot!=this._hazeSlot&&e.slot!=this._skySlot||e.pass!=h.MATERIAL||e.slot==this._hazeSlot&&e.options.earlyOcclusionPixelDraw)){var a,t=this.renderContext.rctx,r=t.gl,s=e.offscreenRenderingHelper,i=!1;if(e.slot==this._hazeSlot){a=this.planar?this._hazePlanarProgram:this._hazeProgram,t.bindProgram(a),t.setBlendFunctionSeparate(r.ONE,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE),s.detachDepthTextureFromBuffer(),i=!0;var n=s.getDepthTexture();t.bindTexture(n,0),a.setUniform1i("tDepth",0),a.setUniform4fv("v4SphereComp",this._renderData.v4SphereComp)}return e.slot==this._skySlot&&(a=this.planar?this._skyPlanarProgram:this._skyProgram,t.bindProgram(a),t.setBlendFunctionSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),a.setUniform4fv("v4SphereComp",this._renderData.v4SphereComp),a.setUniform4fv("v4AtmosParams3",this._renderData.v4AtmosParams3)),a.setUniform3fv("v3InvWavelength",this._renderData.v3InvWavelength),a.setUniform3fv("v3InvWavelengthScaled",this._renderData.v3InvWavelengthScaled),a.setUniform3fv("v3LightDir",e.lightingData.direction),a.setUniform3fv("v3CameraPos",this._renderData.v3CameraPos),a.setUniform3fv("v3CameraUp",this._renderData.v3CameraUp),a.setUniform3fv("v3CameraRight",this._renderData.v3CameraRight),a.setUniform3fv("v3CameraDir",this._renderData.v3CameraDir),a.setUniform2fv("nearFar",this._renderData.nearFar),a.setUniform2fv("halfSizeNearPlane",this._renderData.halfSizeNearPlane),a.setUniform2fv("v2CameraCenterOffset",this._renderData.v2CameraCenterOffset),a.setUniform4fv("v4Radii",this._renderData.v4Radii),a.setUniform4fv("v4AtmosParams1",this._renderData.v4AtmosParams1),a.setUniform4fv("v4AtmosParams2",this._renderData.v4AtmosParams2),a.setUniform1f("showTest",this._renderData.showTest),t.setDepthTestEnabled(!1),t.setBlendingEnabled(!0),this._renderer.render(a),t.setBlendingEnabled(!1),t.setDepthTestEnabled(!0),t.setBlendFunctionSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),i&&s.restoreDepthTextureToBuffer(),!0}},_setEnableTestImage:function(e){e?this._renderData.showTest=1:this._renderData.showTest=0,this.needsRender=!0},_adjustRadiusForTesselation:function(e){var a=16,t=4,r=Math.PI/Math.pow(2,t)/a;return e*Math.cos(r)},_normalizeRadius:function(e){return e=this._adjustRadiusForTesselation(e),Math.max(f-1e4,Math.min(e,f))},_updateElevation:function(){if(this.get("view.basemapTerrain.ready")){var e=this._adjustRadiusForTesselation(f+this.view.basemapTerrain.rootTiles[0].elevationBounds[0]);e!==this._lowerElevationBoundRadius&&(this._lowerElevationBoundRadius=e,this._earthRadius=-1,this._updateVisibleElevationBounds())}},_updateVisibleElevationBounds:function(){var e=this._adjustRadiusForTesselation(f+this.view.basemapTerrain.getElevationBounds()[0]);return this._earthRadius<0||e<this._earthRadius?this._updateRadius(e):!1},_updateRadius:function(e){this._earthRadius=e;var a=e,t=a*a,r=a/10*10.25,s=r*r,i=1/(r-a),n=i/A,h=i/w,o=.3*(r-a)+a,l=1/(r-o),d=this._renderData;return c.set4(i,A,n,b,d.v4AtmosParams1),c.set4(E,w,h,U,d.v4AtmosParams2),c.set4(E*E,O,o,l,d.v4AtmosParams3),c.set4(a,t,r,s,d.v4Radii),d.fScale=i,d.fLowerAlphaBlendBound=o,d.fScaleOverScaleDepth=n,d.fScaleOverScaleDepthBlue=h,this._update(),!0},_update:function(e){if(e=e||this.get("view.navigation.currentCamera")){if(u.negate(e.viewForward,this._renderData.v3CameraDir),u.set(e.viewUp,this._renderData.v3CameraUp),u.set(e.viewRight,this._renderData.v3CameraRight),this.planar){var a=this.view.renderCoordsHelper;this._renderData.fCameraHeight=a.getAltitude(e.eye)/a.unitInMeters+f}else this._renderData.fCameraHeight=u.length(e.eye);this._renderData.fCameraHeight2=this._renderData.fCameraHeight*this._renderData.fCameraHeight,this._renderData.fC=this._renderData.fCameraHeight2-this._renderData.v4Radii[3],this._renderData.fCSur=this._renderData.fCameraHeight2-this._renderData.v4Radii[1],this._renderData.v4SphereComp=c.createFrom(this._renderData.fCameraHeight,this._renderData.fCameraHeight2,this._renderData.fC,this._renderData.fCSur),u.set(e.eye,this._renderData.v3CameraPos),u.set(e.center,this._renderData.v3CameraCenter),p.set2(Math.tan(e.fovX/2)/(e.width/e.fullWidth),Math.tan(e.fovY/2)/(e.height/e.fullHeight),this._renderData.halfSizeNearPlane);var t=(e.padding[3]+e.width/2)/e.fullWidth,r=(e.padding[2]+e.height/2)/e.fullHeight;p.set2(t-.5,r-.5,this._renderData.v2CameraCenterOffset),p.set2(e.near,e.far,this._renderData.nearFar),this.needsRender=!0}}});return T.isSupported=function(e){return l.supportsDepthTexture(e.rctx.extensions)},T});