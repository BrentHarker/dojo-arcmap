require({cache:{
'url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml':"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<snippets>\n\n<snippet name=\"vertexShaderHUD\"><![CDATA[\n  $vsprecisionf\n\n  $commonAttributesAndUniformsHUD\n\n  uniform float pixelRatio;\n  uniform vec2 screenOffset;\n  uniform vec2 anchorPos;\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n\n  uniform vec4 screenSizePerspective;\n\n#endif\n\n#ifdef DEBUG_DRAW_BORDER\n  varying vec3 debugBorderCoords;\n#endif\n\n  attribute vec2 $uv0;\n  attribute vec4 $color;\n  attribute vec2 $size;\n  attribute vec4 $auxpos2;\n\n  varying vec4 vcolor;\n\n  varying vec2 vtc;\n  varying vec2 vsize;\n\n  $vvUniforms\n\n  $alignToPixelCenter\n  $alignToPixelOrigin\n  $projectPositionHUD\n  $vvFunctions\n\n  void main(void) {\n    ProjectHUDAux projectAux;\n    vec4 posProj = projectPositionHUD(projectAux);\n\n    vec2 inputSize;\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n\n    inputSize = screenSizePerspectiveScaleVec2($size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n\n    vec2 screenOffsetScaled = screenSizePerspectiveScaleFloat(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n\n#else\n\n    inputSize = $size;\n\n    vec2 screenOffsetScaled = screenOffset;\n#endif\n\n#ifdef VV_SIZE\n    // only use width (.xx) for proportional scaling\n    // (if no width was defined in vv, width\n    //  will be a copy of height vv)\n    inputSize *= vvGetScale($auxpos2).xx;\n#endif\n\n    vec2 combinedSize = inputSize * pixelRatio;\n    vec4 quadOffset = vec4(0);\n\n#ifdef OCCL_TEST\n    if (testVisibilityHUD(posProj)) {\n#endif\n      // UV goes from 0 to 1.99999, where the integer part is used\n      // for the normalized vertex coordinates, and the fractional\n      // part is used for texture sampling\n      vec2 uv01 = floor($uv0);\n      vec2 uv = $uv0 - uv01;\n\n      // Displace icon based on anchor position (normalized for size) and\n      // absolute screen offset. anchorPos is [-0.5, 0.5]\n      quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\n\n#ifdef SIGNED_DISTANCE_FIELD\n\n      // SDF primitives might be scaled so that the SDF texture resolution does\n      // not match the resolution of the canvas, but we still want to render\n      // outline-only ('cross' and 'x') primitives cleanly. Aligning to a screen\n      // pixel border at the geometry center achieves this, since SDF textures\n      // always have power of 2 dimensions.\n      posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\n#else\n      posProj += quadOffset;\n\n      // Aligning vertex positions to the nearest (using 'floor') screen pixel\n      // border renders textures with pixel-perfect results. If the texture\n      // resolution does not match the canvas resolution then aligning is\n      // redundant.\n      if (inputSize.x == $size.x) {\n        posProj = alignToPixelOrigin(posProj, viewport.zw);\n      }\n#endif\n\n      gl_Position = posProj;\n\n      vtc = uv;\n\n#ifdef DEBUG_DRAW_BORDER\n      debugBorderCoords = vec3(uv01, 1.0 / combinedSize);\n#endif\n\n      vsize = inputSize;\n#ifdef OCCL_TEST\n    } else {\n      vtc = vec2(.0);\n\n#ifdef DEBUG_DRAW_BORDER\n      debugBorderCoords = vec3(0);\n#endif\n\n    }\n#endif\n\n    gl_Position = posProj;\n\n#ifdef VV_COLOR\n    vcolor = vvGetColor($auxpos2, vvColorValues, vvColorColors);\n#else\n    vcolor = $color / 255.0;\n#endif\n  }\n]]></snippet>\n\n<snippet name=\"fragmentShaderHUDBaseVariables\"><![CDATA[\n  $fsprecisionf\n\n  #extension GL_OES_standard_derivatives : require\n\n  uniform sampler2D tex;\n  uniform vec4 overrideColor;\n  uniform vec4 outlineColor;\n  uniform float outlineSize;\n\n  varying vec4 vcolor;\n\n  varying vec2 vtc;\n  varying vec2 vsize;\n\n#ifdef DEBUG_DRAW_BORDER\n  varying vec3 debugBorderCoords;\n#endif\n]]></snippet>\n\n<snippet name=\"fragmentShaderHUDBaseMain\"><![CDATA[\n  vec4 premultiply(vec4 v) {\n    return vec4(v.rgb * v.a, v.a);\n  }\n\n  void main() {\n\n#ifdef SIGNED_DISTANCE_FIELD\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 fillPixelColor = overrideColor * vcolor;\n\n    // Attempt to sample texel centers to avoid thin cross outline\n    // disappearing with large symbol sizes.\n    // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\n    const float txSize = 128.0;\n    vec2 scaleFactor = ((vsize - txSize) / txSize);\n    vec2 samplePos = vtc + vec2(1.0, -1.0) * (1.0 / txSize) * scaleFactor;\n\n    // Distance in [-0.5, 0.5]\n    float d = dot(texture2D(tex, samplePos), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\n\n    // Work around loss of precision for 'd = 0.0'.\n    // '0' gets normalised to 0.5 * 256 = 128 before float packing, but can only\n    // be stored in the texture as 128 / 255 = 0.502.\n    // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603110\n    const float diff = (128.0/255.0 - 0.5);\n\n    // adjust all values, not just those close to 0, to avoid discontinuities in\n    // the outlines of other shapes e.g. circles\n    d = d - diff;\n\n    // Distance in output units\n    float dist = d * vsize.x;\n\n    fillPixelColor.a *= clamp(0.5 - dist, 0.0, 1.0);\n\n    if (outlineSize > 0.25) {\n      vec4 outlinePixelColor = outlineColor;\n      float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n      outlinePixelColor.a *= clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\n\n      // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n      float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n      vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n        vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n      gl_FragColor = vec4(compositeColor, compositeAlpha);\n    }\n    else {\n      gl_FragColor = premultiply(fillPixelColor);\n    }\n\n    // visualize SDF:\n    // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n#else\n\n    // HUDMaterial is rendered with a blending mode that assumes a pre-multiplied\n    // fragment color. Input textures should already be pre-multiplied and so\n    // don't require adjustment, but the override and vertex colors must be\n    // modulated by their alpha values.\n\n    gl_FragColor = texture2D(tex, vtc, -0.5) * premultiply(overrideColor * vcolor);\n\n#endif\n\n#ifdef DEBUG_DRAW_BORDER\n     float isBorder = float(any(lessThan(debugBorderCoords.xy, vec2(debugBorderCoords.z))) || any(greaterThan(debugBorderCoords.xy, vec2(1.0 - debugBorderCoords.z))));\n     gl_FragColor = mix(gl_FragColor, vec4(1, 0, 1, 1), isBorder);\n#endif\n\n    if (gl_FragColor.a < 0.1) {\n      discard;\n    }\n\n]]></snippet>\n\n<snippet name=\"fragmentShaderHUD\"><![CDATA[\n$fragmentShaderHUDBaseVariables\n$fragmentShaderHUDBaseMain\n  }\n]]></snippet>\n\n<snippet name=\"fragmentShaderHUDHighlight\"><![CDATA[\n$fragmentShaderHUDBaseVariables\n\n  uniform sampler2D depthTex;\n  uniform vec4 highlightViewportPixelSz;\n\n$fragmentShaderHUDBaseMain\n    $highlightWrite\n  }\n]]></snippet>\n\n\n<snippet name=\"vertexShaderOcclusionTestPixel\"><![CDATA[\n  $vsprecisionf\n\n  $commonAttributesAndUniformsHUD\n\n  $alignToPixelCenter\n  $projectPositionHUD\n\n  void main(void) {\n    vec4 posProjCenter;\n\n    // Check for special value of position (0, 0, 0) which is used by the Renderer when graphics\n    // are removed before the VBO is recompacted. If this is the case, then we just project outside\n    // of clip space.\n    if (dot($position, $position) > 0.0) {\n      // Render single point to center of the pixel to avoid subpixel filtering to affect\n      // the marker color\n      ProjectHUDAux projectAux;\n      vec4 posProj = projectPositionHUD(projectAux);\n\n      posProjCenter = alignToPixelCenter(posProj, viewport.zw);\n    }\n    else {\n      // Project out of clip space\n      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n    }\n\n    gl_Position = posProjCenter;\n    gl_PointSize = 1.0;\n  }\n]]></snippet>\n\n</snippets>\n"}});
// COPYRIGHT Â© 2017 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.4/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/extendsHelper","dojo/text!./HUDMaterial.xml","./internal/MaterialUtil","../lib/Util","../../../webgl/Util","./internal/MaterialBase","./internal/GLMaterialTextureBase","../lib/gl-matrix","../lib/RenderSlot","../lib/ShaderVariations","../lib/ComponentUtils","../../support/aaBoundingRect","../lib/screenSizePerspectiveUtils"],function(e,t,r,i,n,o,a,s,l,c,f,d,v,u,p){function S(e,t){return void 0===t&&(t=M),e.textureIsSignedDistanceField?g(e.anchorPos,e.distanceFieldBoundingBox,t):h.set(e.anchorPos,t),t}function m(e,t,r,i){return void 0===i&&(i=M),h.set(e.anchorPos,i),i[0]*=-t[0],i[1]*=-t[1],i[0]+=e.screenOffset[0]*r,i[1]+=e.screenOffset[1]*r,i}function g(e,t,r){r[0]=e[0]*(t[2]-t[0])+t[0],r[1]=e[1]*(t[3]-t[1])+t[1]}var h=c.vec2d,x=c.vec3d,P=c.mat3d,A=c.mat4d,O=76,z=O/4,C="hud-material-shader-variations",y="hud-material-highlight-shader-variations",V="hud-material-occlusion-test-pixel-shader-variations",b={"bottom-left":[0,0],bottom:[.5,0],"bottom-right":[1,0],left:[0,.5],center:[.5,.5],right:[1,.5],"top-left":[0,1],top:[.5,1],"top-right":[1,1]},E=[{name:"position",count:3,type:5126,offset:0,stride:O,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:O,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,stride:O,normalized:!1},{name:"color",count:4,type:5121,offset:32,stride:O,normalized:!1},{name:"size",count:2,type:5126,offset:36,stride:O,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:44,stride:O,normalized:!1},{name:"auxpos2",count:4,type:5126,offset:60,stride:O,normalized:!1}],I={texCoordScale:[1,1],occlusionTest:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,anchorPos:b.center,shaderPolygonOffset:1e-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",debugDrawBorder:!1},U=function(e){function t(t,r){var i=e.call(this,r)||this;return i._textureDirty=!1,i.params=n.copyParameters(t,I),"string"==typeof i.params.anchorPos&&(i.params.anchorPos=b[i.params.anchorPos]),i}return r(t,e),t.prototype.dispose=function(){},t.prototype.getParameterValues=function(){var e=this.params;return{color:e.color,texCoordScale:e.texCoordScale,polygonOffset:e.polygonOffset,anchorPos:e.anchorPos,screenOffset:e.screenOffset,verticalOffset:e.verticalOffset,screenSizePerspective:e.screenSizePerspective,screenSizePerspectiveAlignment:e.screenSizePerspectiveAlignment,shaderPolygonOffset:e.shaderPolygonOffset,textureIsSignedDistanceField:e.textureIsSignedDistanceField,outlineColor:e.outlineColor,outlineSize:e.outlineSize,distanceFieldBoundingBox:e.distanceFieldBoundingBox,vvSizeEnabled:e.vvSizeEnabled,vvSizeMinSize:e.vvSizeMinSize,vvSizeMaxSize:e.vvSizeMaxSize,vvSizeOffset:e.vvSizeOffset,vvSizeFactor:e.vvSizeFactor,vvColorEnabled:e.vvColorEnabled,vvColorValues:e.vvColorValues,vvColorColors:e.vvColorColors,textureId:e.textureId,occlusionTest:e.occlusionTest,centerOffsetUnits:e.centerOffsetUnits,debugDrawBorder:e.debugDrawBorder,drawInSecondSlot:e.drawInSecondSlot}},t.prototype.setParameterValues=function(e){for(var t in e)"textureId"===t&&o.assert(!!this.params.textureId,"Can only change texture of material that already has a texture"),this.params[t]=e[t];this.notifyDirty("matChanged")},t.prototype.getParams=function(){return this.params},t.prototype.getOutputAmount=function(e){return e*z*6},t.prototype.getInstanceBufferLayout=function(){},t.prototype.getVertexBufferLayout=function(){return E},t.prototype.fillInterleaved=function(e,t,r,i,s,l){for(var c=4*l,f=e.faces.indices[o.VertexAttrConstants.POSITION],d=e.vertexAttr[o.VertexAttrConstants.POSITION].data,v=l+a.findAttribute(E,o.VertexAttrConstants.POSITION).offset/4,u=0;u<f.length;++u){var p=3*f[u];n.fill(d,p,s,v,t,3),v+=z,n.fill(d,p,s,v,t,3),v+=z,n.fill(d,p,s,v,t,3),v+=z,n.fill(d,p,s,v,t,3),v+=z,n.fill(d,p,s,v,t,3),v+=z,n.fill(d,p,s,v,t,3),v+=z}for(var S=e.faces.indices[o.VertexAttrConstants.NORMAL],m=e.vertexAttr[o.VertexAttrConstants.NORMAL].data,g=l+a.findAttribute(E,o.VertexAttrConstants.NORMAL).offset/4,u=0;u<S.length;++u){var p=3*S[u];n.fill(m,p,s,g,r,3),g+=z,n.fill(m,p,s,g,r,3),g+=z,n.fill(m,p,s,g,r,3),g+=z,n.fill(m,p,s,g,r,3),g+=z,n.fill(m,p,s,g,r,3),g+=z,n.fill(m,p,s,g,r,3),g+=z}var h,x,P,A,C=e.vertexAttr[o.VertexAttrConstants.UV0].data;null==C||C.length<=3?(h=0,x=0,P=this.params.texCoordScale[0],A=this.params.texCoordScale[1]):(h=e.vertexAttr[o.VertexAttrConstants.UV0].data[0],x=e.vertexAttr[o.VertexAttrConstants.UV0].data[1],P=e.vertexAttr[o.VertexAttrConstants.UV0].data[2],A=e.vertexAttr[o.VertexAttrConstants.UV0].data[3]),P=Math.min(1.99999,P+1),A=Math.min(1.99999,A+1);for(var y=l+a.findAttribute(E,o.VertexAttrConstants.UV0).offset/4,u=0;u<f.length;++u)s[y]=h,s[y+1]=x,y+=z,s[y]=P,s[y+1]=x,y+=z,s[y]=P,s[y+1]=A,y+=z,s[y]=P,s[y+1]=A,y+=z,s[y]=h,s[y+1]=A,y+=z,s[y]=h,s[y+1]=x,y+=z;for(var V=e.faces.indices[o.VertexAttrConstants.COLOR],b=e.vertexAttr[o.VertexAttrConstants.COLOR].data,I=c+a.findAttribute(E,o.VertexAttrConstants.COLOR).offset,U=new Uint8Array(s.buffer),u=0;u<V.length;++u){var p=4*V[u];n.fill(b,p,U,I,null,4),I+=O,n.fill(b,p,U,I,null,4),I+=O,n.fill(b,p,U,I,null,4),I+=O,n.fill(b,p,U,I,null,4),I+=O,n.fill(b,p,U,I,null,4),I+=O,n.fill(b,p,U,I,null,4),I+=O}for(var D=e.faces.indices[o.VertexAttrConstants.SIZE],T=e.vertexAttr[o.VertexAttrConstants.SIZE].data,R=l+a.findAttribute(E,o.VertexAttrConstants.SIZE).offset/4,u=0;u<D.length;++u){var F=T[2*D[u]],M=T[2*D[u]+1];s[R]=F,s[R+1]=M,R+=z,s[R]=F,s[R+1]=M,R+=z,s[R]=F,s[R+1]=M,R+=z,s[R]=F,s[R+1]=M,R+=z,s[R]=F,s[R+1]=M,R+=z,s[R]=F,s[R+1]=M,R+=z}if(null!=e.faces.indices[o.VertexAttrConstants.AUXPOS1]&&null!=e.vertexAttr[o.VertexAttrConstants.AUXPOS1])for(var w=e.faces.indices[o.VertexAttrConstants.AUXPOS1],B=e.vertexAttr[o.VertexAttrConstants.AUXPOS1].data,L=l+a.findAttribute(E,"auxpos1").offset/4,u=0;u<w.length;++u){var p=4*w[u];n.fill(B,p,s,L,null,4),L+=z,n.fill(B,p,s,L,null,4),L+=z,n.fill(B,p,s,L,null,4),L+=z,n.fill(B,p,s,L,null,4),L+=z,n.fill(B,p,s,L,null,4),L+=z,n.fill(B,p,s,L,null,4),L+=z}if(null!=e.faces.indices[o.VertexAttrConstants.AUXPOS2]&&null!=e.vertexAttr[o.VertexAttrConstants.AUXPOS2])for(var N=e.faces.indices[o.VertexAttrConstants.AUXPOS2],_=e.vertexAttr[o.VertexAttrConstants.AUXPOS2].data,H=l+a.findAttribute(E,"auxpos2").offset/4,u=0;u<N.length;++u){var p=4*N[u];n.fill(_,p,s,H,null,4),H+=z,n.fill(_,p,s,H,null,4),H+=z,n.fill(_,p,s,H,null,4),H+=z,n.fill(_,p,s,H,null,4),H+=z,n.fill(_,p,s,H,null,4),H+=z,n.fill(_,p,s,H,null,4),H+=z}},t.prototype.intersect=function(e,t,r,i,n,a,s,l){if(i.isSelection&&i.enableHUDSelection&&!v.isAllHidden(t.componentVisibilities,e.data.componentOffsets)){var c=this.params,f=1,d=1;if(l){var u=l(Z);f=u[0],d=u[5]}var m=e.getData().getVertexAttr()[o.VertexAttrConstants.POSITION],g=e.getData().getVertexAttr()[o.VertexAttrConstants.SIZE],h=e.getData().getVertexAttr()[o.VertexAttrConstants.NORMAL];o.assert(m.size>=3);for(var P=i.point,O=i.camera,z=S(c),C=0;C<m.data.length/m.size;C++){var y=C*m.size;x.set3(m.data[y],m.data[y+1],m.data[y+2],w),A.multiplyVec3(r,w,w);var V=C*g.size;q[0]=g.data[V]*f,q[1]=g.data[V+1]*d,A.multiplyVec3(O.viewMatrix,w);var b=C*h.size;if(x.set3(h.data[b],h.data[b+1],h.data[b+2],B),this.applyVerticalOffsetTransformation(w,B,r,O,F),O.applyProjection(w,L),L[0]>-1){var E=Math.floor(L[0]),I=Math.floor(L[1]);p.applyPrecomputedScaleFactorVec2(q,F.factor,q);var U=E-j-(z[0]>0?q[0]*z[0]:0),D=U+q[0]+2*j,T=I-j-(z[1]>0?q[1]*z[1]:0),R=T+q[1]+2*j;if(c.textureIsSignedDistanceField){var M=c.outlineSize/2,N=c.distanceFieldBoundingBox;U+=q[0]*N[0],T+=q[1]*N[1],D-=q[0]*(1-N[2]),R-=q[1]*(1-N[3]),U-=M,D+=M,T-=M,R+=M}if(P[0]>U&&P[0]<D&&P[1]>T&&P[1]<R){var H=i.p0,G=i.p1;A.multiplyVec3(A.inverse(O.viewMatrix,X),w,_),L[0]=P[0],L[1]=P[1],O.unprojectPoint(L,w);var Q=x.negate(i.getDirection(),x.create()),W=x.dist(H,w)/x.dist(H,G);s(W,Q,-1,1,!0,_)}}}}},t.prototype.normalAndViewAngle=function(e,t,r,i){return void 0===i&&(i=G),P.multiplyVec3(A.toMat3(t,H),e,i.normal),A.multiplyVec3(r.viewInverseTransposeMatrix,i.normal),i.cosAngle=x.dot(N,Q),i},t.prototype.updateScaleInfo=function(e,t,r){var i=this.params;i.screenSizePerspective?e.factor=p.precomputeScaleFactor(G.cosAngle,r,i.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),i.screenSizePerspectiveAlignment?(e.scaleAlignment=p.precomputeScale(G.cosAngle,r,i.screenSizePerspectiveAlignment),e.minPixelSizeAlignment=i.screenSizePerspectiveAlignment.parameters.minPixelSize):(e.scaleAlignment=e.factor.scale,e.minPixelSizeAlignment=e.factor.minPixelSize)},t.prototype.applyVerticalOffsetTransformation=function(e,t,r,i,o,a){var s=this.params;if(!s.verticalOffset||!s.verticalOffset.screenLength){if(o&&(s.screenSizePerspective||s.screenSizePerspectiveAlignment)){var l=this.normalAndViewAngle(t,r,i),c=x.length(e);this.updateScaleInfo(o,l.cosAngle,c)}else o&&(o.factor.scale=1,o.scaleAlignment=1);return a?x.set(e,a):e}var f=this.normalAndViewAngle(t,r,i),d=x.length(e),v=s.screenSizePerspectiveAlignment||s.screenSizePerspective,u=n.verticalOffsetAtDistance(i,d,s.verticalOffset,f.cosAngle,v);return o&&this.updateScaleInfo(o,f.cosAngle,d),x.add(e,x.scale(f.normal,u),a)},t.prototype.getGLMaterials=function(){return{color:T,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:R}},t.prototype.getAllTextureIds=function(){return[this.params.textureId]},t.prototype.setTextureDirty=function(){this._textureDirty=!0},t.prototype.calculateRelativeScreenBounds=function(e,t,r){return void 0===r&&(r=u.create()),m(this.params,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r},t.prototype.calculateAnchorPosForRendering=function(e){return S(this.params,e)},t.loadShaders=function(e,t,r,n){e._parse(i);var o=function(e){e.addDefine("OcclTest","OCCL_TEST"),e.addDefine("SDF","SIGNED_DISTANCE_FIELD"),e.addDefine("vvSize","VV_SIZE"),e.addDefine("vvColor","VV_COLOR"),e.addDefine("verticalOffset","VERTICAL_OFFSET"),e.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE"),e.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN")},a=new d("hud",["vertexShaderHUD","fragmentShaderHUD"],null,r,t,e,n);o(a),a.addDefine("debugDrawBorder","DEBUG_DRAW_BORDER"),r.addShaderVariations(C,a);var s=new d("hudHighlight",["vertexShaderHUD","fragmentShaderHUDHighlight"],null,r,t,e,n);o(s),r.addShaderVariations(y,s);var l=new d("hudOcclusionTestPixel",["vertexShaderOcclusionTestPixel","fragmentShaderSimple"],null,r,t,e,n);l.addDefine("verticalOffset","VERTICAL_OFFSET"),l.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE"),l.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN"),r.addShaderVariations(V,l)},t}(s.MaterialBase),D=function(e){function t(t,r,i){var o=e.call(this,t,t.getParams(),r,i)||this;return o.programRep=r,o.params=n.copyParameters(t.getParams()),o.selectProgram(),o.selectSlot(),o}return r(t,e),t.prototype.selectSlot=function(){this.mainSlot=this.params.drawInSecondSlot?f.HUDMATERIAL2:f.HUDMATERIAL1},t.prototype.beginSlot=function(e){return e===this.mainSlot},t.prototype.getProgram=function(){return this.program},t.prototype.getAllPrograms=function(){return[this.program]},t.prototype.updateParameters=function(){var e=this.material.getParams(),t=this.params;t.color=e.color,t.texCoordScale=e.texCoordScale,t.polygonOffset=e.polygonOffset,t.anchorPos=e.anchorPos,t.screenOffset=e.screenOffset,t.verticalOffset=e.verticalOffset,t.screenSizePerspective=e.screenSizePerspective,t.screenSizePerspectiveAlignment=e.screenSizePerspectiveAlignment,t.shaderPolygonOffset=e.shaderPolygonOffset,t.textureIsSignedDistanceField=e.textureIsSignedDistanceField,t.outlineColor=e.outlineColor,t.outlineSize=e.outlineSize,t.vvSizeEnabled=e.vvSizeEnabled,t.vvSizeMinSize=e.vvSizeMinSize,t.vvSizeMaxSize=e.vvSizeMaxSize,t.vvSizeOffset=e.vvSizeOffset,t.vvSizeFactor=e.vvSizeFactor,t.vvColorEnabled=e.vvColorEnabled,t.vvColorValues=e.vvColorValues,t.vvColorColors=e.vvColorColors,this.updateTexture(e.textureId),this.selectProgram(),this.selectSlot()},t.prototype.bindRender=function(e,t){var r=this.params,i=this.getProgram();this.bindTexture(e,i),i.setUniform1i("hudVisibilityTexture",1),e.bindTexture(t.hudVisibilityTexture,1),e.setActiveTexture(0),i.setUniform4fv("overrideColor",r.color),i.setUniform1f("pixelRatio",t.pixelRatio),r.textureIsSignedDistanceField&&(i.setUniform4fv("outlineColor",r.outlineColor),i.setUniform1f("outlineSize",r.outlineSize)),r.vvSizeEnabled&&(i.setUniform3fv("vvSizeMinSize",r.vvSizeMinSize),i.setUniform3fv("vvSizeMaxSize",r.vvSizeMaxSize),i.setUniform3fv("vvSizeOffset",r.vvSizeOffset),i.setUniform3fv("vvSizeFactor",r.vvSizeFactor)),r.vvColorEnabled&&(i.setUniform1fv("vvColorValues",r.vvColorValues),i.setUniform4fv("vvColorColors",r.vvColorColors)),i.setUniform2fv("texScale",r.texCoordScale),i.setUniform2f("screenOffset",2*r.screenOffset[0],2*r.screenOffset[1]),i.setUniform2fv("anchorPos",S(r)),r.polygonOffset&&(e.setPolygonOffsetFillEnabled(!0),e.setPolygonOffset(0,-4)),e.setBlendingEnabled(!0),e.setBlendFunction(1,771)},t.prototype.bindProjection=function(e,t){this.material._textureDirty&&(this.renderTexture(e),this.material._textureDirty=!1);var r=t.cameraAboveGround?1:-1,i=this.getProgram(),o=this.params;e.bindProgram(i),i.setUniform1f("cameraGroundRelative",r),i.setUniform1f("polygonOffset",o.shaderPolygonOffset),i.setUniform4fv("viewport",t.viewport),n.bindVerticalOffset(o.verticalOffset,t,i),i.setUniformMatrix4fv("viewNormal",t.viewInvTransp),o.screenSizePerspective&&(n.bindScreenSizePerspective(o.screenSizePerspective,i,"screenSizePerspective"),n.bindScreenSizePerspective(o.screenSizePerspectiveAlignment||o.screenSizePerspective,i,"screenSizePerspectiveAlignment"))},t.prototype.releaseRender=function(e){e.setPolygonOffsetFillEnabled(!1),e.setBlendFunction(770,771),e.setBlendingEnabled(!1)},t.prototype.bindView=function(e,t){var r=t.origin,i=this.getProgram();n.bindView(r,t.view,i),n.bindCamPos(r,t.viewInvTransp,i)},t.prototype.bindInstance=function(e,t){var r=this.getProgram();r.setUniformMatrix4fv("model",t.transformation),r.setUniformMatrix4fv("modelNormal",t.transformationNormal)},t.prototype.getDrawMode=function(e){var t=e.gl;return t.TRIANGLES},t}(l.GLMaterialTextureBase),T=function(e){function t(t,r,i){var n=e.call(this,t,r,i)||this;return n.isOcclusionSlot=!1,n}return r(t,e),t.prototype.selectProgram=function(){var e=this.params;this.programOcclusionTestPixel=this.programRep.getShaderVariationsProgram(V,[!!e.verticalOffset,!!e.screenSizePerspective,"screen"===e.centerOffsetUnits]),this.program=this.programRep.getShaderVariationsProgram(C,[e.occlusionTest,e.textureIsSignedDistanceField,!!e.vvSizeEnabled,!!e.vvColorEnabled,!!e.verticalOffset,!!e.screenSizePerspective,"screen"===e.centerOffsetUnits,!!e.debugDrawBorder])},t.prototype.getDrawMode=function(e){var t=e.gl;return this.isOcclusionSlot?t.POINTS:t.TRIANGLES},t.prototype.release=function(e){var t=e.gl;e.setDepthFunction(t.LESS),this.isOcclusionSlot||this.releaseRender(e)},t.prototype.bind=function(e,t){var r=e.gl;this.bindProjection(e,t);var i=this.getProgram();e.setDepthFunction(r.LEQUAL),this.isOcclusionSlot?i.setUniform4f("color",1,1,1,1):(this.bindRender(e,t),this.bindTexture(e,i))},t.prototype.getProgram=function(){return this.isOcclusionSlot?this.programOcclusionTestPixel:this.program},t.prototype.getAllPrograms=function(){return[this.programOcclusionTestPixel,this.program]},t.prototype.beginSlot=function(e){return this.params.occlusionTest?(this.isOcclusionSlot=e===f.OCCLUSION_PIXELS,e===f.OCCLUSION_PIXELS||e===this.mainSlot):(this.isOcclusionSlot=!1,e===this.mainSlot)},t}(D),R=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return r(t,e),t.prototype.selectProgram=function(){var e=this.params;this.program=this.programRep.getShaderVariationsProgram(y,[e.occlusionTest,e.textureIsSignedDistanceField,!!e.vvSizeEnabled,!!e.vvColorEnabled,!!e.verticalOffset,!!e.screenSizePerspective,"screen"===e.centerOffsetUnits])},t.prototype.bind=function(e,t){this.bindProjection(e,t),this.bindRender(e,t)},t.prototype.release=function(e){this.releaseRender(e)},t}(D),F={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},scaleAlignment:0,minPixelSizeAlignment:0},M=[0,0],w=x.create(),B=x.create(),L=x.create(),N=x.create(),_=x.create(),H=P.create(),X=A.create(),G={normal:N,cosAngle:0},Z=A.create();A.identity(Z);var j=1,q=[0,0],Q=[0,0,1];return U});