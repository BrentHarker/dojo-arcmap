require({cache:{
'url:esri/views/3d/webgl-engine/materials/LineCalloutMaterial.xml':"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<snippets>\n\n<snippet name=\"vertexShaderLineCallout\"><![CDATA[\n  $vsprecisionf\n\n  $commonAttributesAndUniformsHUD\n\n  attribute vec2 $uv0;\n\n  uniform float lineSize;\n  uniform vec2 pixelToNDC;\n  uniform float borderSize;\n  uniform vec2 screenOffset;\n\n  varying vec4 coverageSampling;\n  varying vec2 lineSizes;\n\n  $alignToPixelOrigin\n  $alignToPixelCenter\n\n  $projectPositionHUD\n\n  void main(void) {\n    ProjectHUDAux projectAux;\n    vec4 endPoint = projectPositionHUD(projectAux);\n\n#ifdef OCCL_TEST\n    if (!testVisibilityHUD(endPoint)) {\n      gl_Position = vec4(1e38, 1e38, 1e38, 1);\n    }\n    else {\n#endif\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\n      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorFloat(screenOffset, perspectiveFactor);\n#else\n      vec2 screenOffsetScaled = screenOffset;\n#endif\n\n      // Add view dependent polygon offset to get exact same original starting point. This is mostly\n      // used to get the correct depth value\n      vec3 posView = (view * model * vec4($position, 1.0)).xyz;\n      applyHUDViewDependentPolygonOffset($auxpos1.w, projectAux.absCosAngle, posView);\n\n      vec4 startPoint = proj * vec4(posView, 1);\n\n      // Apply screen offset to both start and end point\n      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;\n\n      startPoint.xy += screenOffsetNorm * startPoint.w;\n      endPoint.xy += screenOffsetNorm * endPoint.w;\n\n      // Align start and end to pixel origin\n      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);\n      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);\n\n#ifdef DEPTH_HUD\n\n#ifdef DEPTH_HUD_ALIGN_START\n      endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);\n#else\n      startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);\n#endif\n\n#endif\n\n      vec4 projectedPosition = mix(startAligned, endAligned, $uv0.y);\n\n      // The direction of the line in screen space\n      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);\n      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);\n\n#ifdef SCREEN_SIZE_PERSPECTIVE\n\n      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);\n      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);\n\n#else\n\n      float lineSizeScaled = lineSize;\n      float borderSizeScaled = borderSize;\n\n#endif\n\n      float halfPixelSize = lineSizeScaled * 0.5;\n\n      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned\n      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,\n      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel\n      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).\n      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;\n      float halfPixelSizeInt = floor(halfWholePixelSize);\n\n      // Sub-pixel offset if we need to grow sub-pixels to the left\n      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);\n\n      // Pixel offset aligning to whole pixels and adding subpixel offset if needed\n      float pixelOffset = -halfPixelSizeInt + subpixelOffset;\n\n      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size\n      float padding = 1.0 + borderSizeScaled;\n      vec2 ndcOffset = (pixelOffset - padding + $uv0 * (lineSizeScaled + padding + padding)) * pixelToNDC;\n\n      // Offset x/y from the center of the line in screen space\n      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;\n\n      // Compute a coverage varying which we can use in the fragment shader to determine\n      // how much a pixel is actually covered by the line (i.e. to anti alias the line).\n      // This works by computing two coordinates that can be linearly interpolated and then\n      // subtracted to find out how far away from the line edge we are.\n      float edgeDirection = ($uv0.x * 2.0 - 1.0);\n\n      float halfBorderSize = 0.5 * borderSizeScaled;\n      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;\n      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);\n\n      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);\n\n      coverageSampling = vec4(\n        // Edge coordinate\n        outerEdgeCoverageSampler,\n\n        // Border edge coordinate\n        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,\n\n        // Line offset\n        halfPixelSize - 0.5,\n\n        // Border offset\n        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)\n      );\n\n      lineSizes = vec2(lineSizeScaled, borderSizeScaled);\n\n      gl_Position = projectedPosition;\n\n#ifdef OCCL_TEST\n    }\n#endif\n  }\n]]></snippet>\n\n<snippet><![CDATA[\n\n]]></snippet>\n\n<snippet name=\"fragmentShaderLineCallout\"><![CDATA[\n  $fsprecisionf\n\n  uniform vec4 color;\n  uniform vec4 borderColor;\n\n  varying vec4 coverageSampling;\n  varying vec2 lineSizes;\n\n  void main() {\n    // Mix between line and border coverage offsets depending on whether we need\n    // a border (based on the sidedness).\n    vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);\n\n    // Mix between border and line color based on the line coverage (conceptually the line\n    // blends on top of the border background).\n    //\n    // Anti-alias by blending final result using the full (including optional border) coverage\n    // and the color alpha\n    float borderAlpha = color.a * borderColor.a * coverage.y;\n    float colorAlpha = color.a * coverage.x;\n\n    float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);\n\n#ifdef DEPTH_HUD\n\n    if (finalAlpha < 0.01) {\n      discard;\n    }\n\n#else\n\n    // Compute the finalRgb, but keep it pre-multiplied (for unpre-multiplied you\n    // need to divide by finalAlpha). We avoid the division here by setting the\n    // appropriate blending function in the material.\n    vec3 finalRgb = mix(borderColor.rgb * borderAlpha, color.rgb, colorAlpha);\n\n    gl_FragColor = vec4(finalRgb, finalAlpha);\n\n#endif\n\n  }\n]]></snippet>\n\n</snippets>\n"}});
// COPYRIGHT Â© 2017 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.4/esri/copyright.txt for details.

define(["require","exports","../../../../core/tsSupport/extendsHelper","dojo/text!./LineCalloutMaterial.xml","./internal/MaterialUtil","../lib/Util","../../../webgl/Util","./internal/MaterialBase","./internal/GLMaterialBase","../lib/RenderSlot","../lib/ShaderVariations"],function(e,t,r,i,n,o,a,s,f,l,d){function p(e,t,r){3===r.length?e.setUniform4f(t,r[0],r[1],r[2],1):e.setUniform4fv(t,r)}var c=o.VertexAttrConstants,u=48,h=u/4,m="line-callout-material-shader-variations",g=[{name:"position",count:3,type:5126,offset:0,stride:u,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:u,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,stride:u,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:32,stride:u,normalized:!1}],v={verticalOffset:null,screenSizePerspective:null,screenOffset:[0,0],color:[0,0,0,1],size:1,borderColor:null,occlusionTest:!1,shaderPolygonOffset:1e-5,depthHUDAlignStart:!1,centerOffsetUnits:"world"},S=function(e){function t(r,i){var o=e.call(this,i)||this;return o.params=n.copyParameters(r,v),o._uniqueMaterialIdentifier=t.uniqueMaterialIdentifier(o.params),o}return r(t,e),Object.defineProperty(t.prototype,"uniqueMaterialIdentifier",{get:function(){return this._uniqueMaterialIdentifier},enumerable:!0,configurable:!0}),t.prototype.dispose=function(){},t.prototype.getGLMaterials=function(){return{color:b,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:void 0}},t.prototype.getAllTextureIds=function(){return[]},t.prototype.fillAttributeData=function(e,t,r,i,o,s){var f=e.faces.indices[t],l=e.vertexAttr[t].data;if(f&&l)for(var d=r+a.findAttribute(g,t).offset/4,p=0;p<f.length;p++)for(var c=i*f[p],u=0;6>u;u++)n.fill(l,c,s,d,o,i),d+=h},t.prototype.fillInterleaved=function(e,t,r,i,n,o,s){this.fillAttributeData(e,c.POSITION,o,3,t,n),this.fillAttributeData(e,c.NORMAL,o,3,r,n),this.fillAttributeData(e,c.AUXPOS1,o,4,null,n);for(var f=o+a.findAttribute(g,c.UV0).offset/4,l=0,d=y;l<d.length;l++){var p=d[l];n[f+0]=p[0],n[f+1]=p[1],f+=h}},t.prototype.getOutputAmount=function(e){var t=6;return e*u*t},t.prototype.getInstanceBufferLayout=function(){},t.prototype.getVertexBufferLayout=function(){return g},t.prototype.intersect=function(e,t,r,i,n,o,a,s){},t.prototype.getParameterValues=function(){var e=this.params;return{verticalOffset:e.verticalOffset,screenSizePerspective:e.screenSizePerspective,screenOffset:e.screenOffset,centerOffsetUnits:e.centerOffsetUnits,color:[e.color[0],e.color[1],e.color[2],e.color[3]],size:e.size,borderColor:e.borderColor,occlusionTest:e.occlusionTest,shaderPolygonOffset:e.shaderPolygonOffset,depthHUDAlignStart:e.depthHUDAlignStart}},t.prototype.setParameterValues=function(e){var r=!1;for(var i in e){var n=e[i];void 0!==n&&(r=!0,Array.isArray(n)?this.params[i]=n.slice():this.params[i]=n)}r&&(this._uniqueMaterialIdentifier=t.uniqueMaterialIdentifier(this.params),this.notifyDirty("matChanged"))},t.uniqueMaterialIdentifier=function(e){return JSON.stringify({screenOffset:e.screenOffset||[0,0],centerOffsetUnits:e.centerOffsetUnits||"world"})},t.loadShaders=function(e,t,r,n){e._parse(i);var o=new d("lineCallout",["vertexShaderLineCallout","fragmentShaderLineCallout"],null,r,t,e,n);o.addDefine("occlTest","OCCL_TEST"),o.addDefine("verticalOffset","VERTICAL_OFFSET"),o.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE"),o.addDefine("depthHud","DEPTH_HUD"),o.addDefine("depthHudAlignStart","DEPTH_HUD_ALIGN_START"),o.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN"),r.addShaderVariations(m,o)},t}(s.MaterialBase),b=function(e){function t(t,r,i){var n=e.call(this,t,r,i)||this;return n.isRenderSlot=!0,n.programRep=r,n.updateParameters(),n}return r(t,e),t.prototype.updateParameters=function(){this.params=this.material.getParameterValues(),this.selectProgram()},t.prototype.selectProgram=function(){var e=this.params;this.renderProgram=this.programRep.getShaderVariationsProgram(m,[!!e.occlusionTest,!!e.verticalOffset,!!e.screenSizePerspective,!1,!!e.depthHUDAlignStart,"screen"===e.centerOffsetUnits]),this.depthProgram=this.programRep.getShaderVariationsProgram(m,[!!e.occlusionTest,!!e.verticalOffset,!!e.screenSizePerspective,!0,!!e.depthHUDAlignStart,"screen"===e.centerOffsetUnits])},t.prototype.beginSlot=function(e){switch(e){case l.LINE_CALLOUTS:return this.isRenderSlot=!0,!0;case l.LINE_CALLOUTS_HUD_DEPTH:return this.isRenderSlot=!1,!0}return!1},Object.defineProperty(t.prototype,"program",{get:function(){return this.isRenderSlot?this.renderProgram:this.depthProgram},enumerable:!0,configurable:!0}),t.prototype.getAllPrograms=function(){return[this.renderProgram,this.depthProgram]},t.prototype.getProgram=function(){return this.program},t.prototype.getDrawMode=function(e){return e.gl.TRIANGLES},t.prototype.bind=function(e,t){var r=t.cameraAboveGround?1:-1,i=this.program,o=this.params;e.bindProgram(i),i.setUniform1f("cameraGroundRelative",r),i.setUniform1f("polygonOffset",o.shaderPolygonOffset),i.setUniform4fv("viewport",t.viewport),i.setUniformMatrix4fv("viewNormal",t.viewInvTransp),i.setUniform1i("hudVisibilityTexture",0),e.bindTexture(t.hudVisibilityTexture,0),p(i,"color",o.color),i.setUniform2f("screenOffset",o.screenOffset[0],o.screenOffset[1]),this.bindBorder(e,t),n.bindVerticalOffset(o.verticalOffset,t,i),this.bindSizing(e,t),n.bindScreenSizePerspective(o.screenSizePerspective,i),this.isRenderSlot?this.bindRender(e,t):this.bindHUDDepth(e,t)},t.prototype.bindRender=function(e,t){e.setBlendFunctionSeparate(1,771,770,771),e.setBlendingEnabled(!0),e.setDepthWriteEnabled(!1)},t.prototype.bindHUDDepth=function(e,t){e.setColorMask(!1,!1,!1,!1),e.setDepthWriteEnabled(!0),e.setBlendingEnabled(!1),e.setDepthTestEnabled(!0)},t.prototype.bindView=function(e,t){var r=this.program;n.bindView(t.origin,t.view,r),n.bindCamPos(t.origin,t.viewInvTransp,r)},t.prototype.bindInstance=function(e,t){var r=this.program;r.setUniformMatrix4fv("model",t.transformation),r.setUniformMatrix4fv("modelNormal",t.transformationNormal)},t.prototype.release=function(e,t){this.isRenderSlot?this.releaseRender(e,t):this.releaseHUDDepth(e,t)},t.prototype.releaseRender=function(e,t){e.setBlendingEnabled(!1),e.setBlendFunction(770,771),e.setDepthWriteEnabled(!0)},t.prototype.releaseHUDDepth=function(e,t){e.setColorMask(!0,!0,!0,!0)},t.prototype.bindSizing=function(e,t){var r=this.program,i=this.params;r.setUniform2f("pixelToNDC",2/t.viewport[2],2/t.viewport[3]),r.setUniform1f("lineSize",Math.ceil(i.size))},t.prototype.bindBorder=function(e,t){var r=this.program,i=this.params;null!==i.borderColor?(p(r,"borderColor",i.borderColor),r.setUniform1f("borderSize",1)):(r.setUniform4f("borderColor",0,0,0,0),r.setUniform1f("borderSize",0))},t}(f.GLMaterialBase),y=[[0,0],[1,0],[0,1],[1,0],[1,1],[0,1]];return S});